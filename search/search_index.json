{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#a-ble-bluetooth-low-energy-neighbour-discovery-protocol-on-nrf52","title":"A BLE (Bluetooth Low Energy) Neighbour Discovery Protocol on nRF52","text":"<p>This exemplar demonstrates the implementation of a BLE neighbor discovery protocol on the nRF52 platform using nRF Connect for VS Code. Each device alternates between advertising and scanning according to a scheduled time pattern, enabling unidirectional neighbor discovery. Once a peer is discovered, the device initiates a connection and uses a custom BLE service to exchange data. </p> <p>Although Nordic provides a BLE tutorial course, the official examples typically demonstrate a device in the Peripheral role (GAP, Generic Access Profile) or Server role (GATT, Generic Attribute Profile) interacting with a mobile app. This exemplar goes further by walking through the Central and Client as well, enabling your devices to interact directly with each other.</p> <p>This exemplar was developed at Imperial College London by Sabrina Wang in collaboration with Jay DesLauriers from Research Software Engineering and Dan Cummins from Research Computing &amp; Data Science at the Early Career Researcher Institute.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes \ud83c\udf93","text":"<p>After completing this exemplar, students will:</p> <ul> <li>Understand basic BLE stack concepts.</li> <li>Implement BLE advertising, scanning, and connection.</li> <li>Build a simple neighbor discovery and data exchange application using BLE services.</li> </ul>"},{"location":"#target-audience","title":"Target Audience \ud83c\udfaf","text":"<ul> <li> <p>Graduate and undergraduate students new to BLE technology who need practical experience for their research or projects.</p> </li> <li> <p>Students seeking a hands-on introduction to BLE neighbor discovery protocols and GATT services.</p> </li> <li> <p>Learners interested in wireless communication and low-power device design using nRF52 platforms.</p> </li> <li> <p>Anyone aiming to build foundational BLE skills for academic coursework or prototyping.</p> </li> </ul>"},{"location":"#prerequisites","title":"Prerequisites \u2705","text":""},{"location":"#academic","title":"Academic \ud83d\udcda","text":"<ul> <li> <p>Basic knowledge of C programming (variables, functions, control structures).</p> </li> <li> <p>No prior experience with BLE is required \u2014 this exemplar includes guidance and references to official BLE tutorials to support beginners.</p> </li> </ul>"},{"location":"#system","title":"System \ud83d\udcbb","text":"<ul> <li> <p>A Nordic BLE development board (e.g. nRF52832 DK or nRF52840 DK).</p> </li> <li> <p>A USB cable for programming and serial communication.</p> </li> <li> <p>A development environment set up by following Lesson 1 of Nordic's official nRF Connect SDK Fundamentals course:</p> </li> </ul> <p>\ud83d\udc49 https://academy.nordicsemi.com/courses/bluetooth-low-energy-fundamentals/</p>"},{"location":"#getting-started","title":"Getting Started \ud83d\ude80","text":"<ol> <li> <p>Before diving into this exemplar, it\u2019s important to ensure your development environment is properly set up. We highly recommend starting with Lesson 1, Exercise 1 from Nordic Semiconductor\u2019s official nRF Connect SDK Fundamentals tutorial. This exercise will guide you step-by-step through installing the essential development tools and configuring your environment for success.</p> </li> <li> <p>Once you\u2019re comfortable with that, take a moment to complete Exercise 2. It offers practical experience in building and flashing applications onto your development board using the nRF Connect SDK. If you\u2019re new to Nordic\u2019s workflow, this exercise will be especially valuable in helping you become familiar with compiling firmware and programming your device smoothly.</p> </li> <li> <p>The Notebook: demo notebook walks you through the beginner-level example in the <code>demo</code> folder step by step:</p> <ul> <li>Learn the theory: It first refers to the What is BLEnd? Theoretical Foundations and BLE Advertising and Scanning: What You Need to Know documents in the <code>docs</code> folder to introduce the basics of BLE and the BLEnd protocol.   </li> <li>Understand the code: Next, it uses the How to Use a Timer and Introduction to GAP. document to explain how the example code interacts with the official BLE API (Application Programming Interface).   </li> <li>See the results: Finally, it presents the observed output so you can compare your own results with the expected behavior. In this stage, you should see your devices scanning and advertising, allowing them to discover nearby devices.  </li> </ul> </li> <li> <p>The <code>demo_connect</code> example is designed as a challenge exercise, encouraging more self-directed learning. It builds on the basics from the <code>demo</code> example and introduces additional concepts, such as creating and using a customized GATT service after establishing a connection. The Notebook: demo_connect notebook provides learning resources, service explanation and observed results.</p> </li> </ol>"},{"location":"#project-structure","title":"Project Structure \ud83d\uddc2\ufe0f","text":"<p>Overview of code organisation and structure.</p> <pre><code>.\n\u251c\u2500\u2500 demo\n\u2502 \u251c\u2500\u2500 src\n\u2502 \u2502 \u251c\u2500\u2500 advertiser_scanner.c\n\u2502 \u2502 \u251c\u2500\u2500 advertiser_scanner.h\n\u2502 \u2502 \u251c\u2500\u2500 blend.c\n\u2502 \u2502 \u251c\u2500\u2500 blend.h\n\u2502 \u2502 \u251c\u2500\u2500 main.c\n\u2502 \u251c\u2500\u2500 CMakeLists.txt\n\u2502 \u251c\u2500\u2500 prj.conf\n\u251c\u2500\u2500 demo_connect\n\u2502 \u251c\u2500\u2500 src\n\u2502 \u2502 \u251c\u2500\u2500 advertiser_scanner.c\n\u2502 \u2502 \u251c\u2500\u2500 advertiser_scanner.h\n\u2502 \u2502 \u251c\u2500\u2500 blend.c\n\u2502 \u2502 \u251c\u2500\u2500 blend.h\n\u2502 \u2502 \u251c\u2500\u2500 main.c\n\u2502 \u2502 \u251c\u2500\u2500 my_lbs.c\n\u2502 \u2502 \u251c\u2500\u2500 my_lbs.h\n\u2502 \u2502 \u251c\u2500\u2500 my_lbs_client.c\n\u2502 \u2502 \u251c\u2500\u2500 my_lbs_client.h\n\u2502 \u251c\u2500\u2500 CMakeLists.txt\n\u2502 \u251c\u2500\u2500 prj.conf\n\u251c\u2500\u2500 docs\n\u2502 \u251c\u2500\u2500 BLE_Background.md\n\u2502 \u251c\u2500\u2500 BLEnd.md\n\u2502 \u251c\u2500\u2500 introduction_to_GAP.md\n\u2502 \u251c\u2500\u2500 introduction_to_Ktimer.md\n\u251c\u2500\u2500 notebooks\n\u2502 \u251c\u2500\u2500 demo.md\n\u2502 \u251c\u2500\u2500 demo_connect.md\n\u2514\u2500\u2500  README.md\n</code></pre> <p>Code is organised into logical components: - <code>demo</code> for beginner-level code, potentially divided into further modules - <code>demo_connect</code> for challenge code, potentially divided into further modules - <code>docs</code> for documentation - <code>notebooks</code> for tutorials and exercises</p>"},{"location":"#estimated-time","title":"Estimated Time \u23f3","text":"Task Time Reading 4 hours Practising 2 hours"},{"location":"#additional-resources","title":"Additional Resources \ud83d\udd17","text":"<ul> <li>nRF Connect SDK Fundamentals</li> <li>Bluetooth Low Energy Fundamentals</li> </ul>"},{"location":"#licence","title":"Licence \ud83d\udcc4","text":"<p>This project is licensed under the BSD-3-Clause license.</p>"},{"location":"BLE_Background/","title":"BLE Background","text":""},{"location":"BLE_Background/#ble-advertising-and-scanning-what-you-need-to-know","title":"BLE Advertising and Scanning: What You Need to Know","text":"<p>This guide is all about getting you up to speed on the core concepts of BLE (Bluetooth Low Energy) advertising and scanning. This introduction is based on Lesson 2 of Nordic's excellent BLE Fundamentals tutorial. If you've got some time and want to dive deeper into the underlying theory, we highly recommend checking out their full tutorial. But if you're short on time and just need the essentials to get going, you can simply breeze through this document\u2014it'll give you a solid foundation!  </p> <p>A Note on Device Roles     Throughout the Nordic course above, you'll notice us using different terms for devices, sometimes \"scanner\" and \"advertiser,\" and other times \"central\" and \"peripheral.\" This can be a bit confusing, but it reflects the different roles devices play during the Bluetooth Low Energy (BLE) communication process.      Here's why:     Discovery Phase: In the initial discovery phase, a device actively sending out broadcast packets is called an \"advertiser.\" A device listening for these advertisements is a \"scanner.\" The scanner's goal here is often to find advertisers it wants to connect with.     Connection Phase: If a scanner decides to initiate a connection with an advertiser, and that connection is successful, their roles evolve:     The scanner transitions into a \"central\" device.     The advertiser becomes a \"peripheral\" device.     So, while \"scanner\" and \"advertiser\" describe roles during the discovery and advertising process, \"central\" and \"peripheral\" describe their roles once a connection has been established. Throughout this document, we'll consistently use the terms \"scanner\" and \"advertiser\" when discussing device roles.</p>"},{"location":"BLE_Background/#advertising-and-discovery","title":"Advertising and Discovery","text":""},{"location":"BLE_Background/#channels","title":"Channels","text":"<p>Bluetooth LE devices communicate through 40 different frequency channels. <code>Channel 37</code>, <code>Channel 38</code>, <code>Channel 39</code> are mainly used for advertisement purposes. Other channels are mainly used for data transfer after establishing a connection.</p> <p></p>"},{"location":"BLE_Background/#advertising-and-discovery-process","title":"Advertising and Discovery Process","text":"<p>Definition of Terms</p> <ul> <li> <p>Advertising intervals:\u00a0The interval at which an advertising packet is sent. This can range from 20 ms to 10.24 s, with a step increase of 0.625 ms.</p> </li> <li> <p>Scan interval: The interval at which a device scans for advertisement packets.</p> </li> <li>Scan window: The time that a device spends scanning for packets at each scan interval. Both scan interval and scan window range from 2.5 ms to 10.24 seconds with a step increase of 0.625 ms.  </li> </ul> <p>Process </p> <p>Since BLE operates in the crowded industrial, scientific, and medical radio band (ISM band), it has to share the airwaves with other technologies like Wi-Fi. This means there's always a risk of interference. On top of that, if two BLE devices try to send a signal on the same channel at the exact same time, they'll interfere with each other, making it hard for either message to get through. To increase the chances that advertising packets will be received by other devices, BLE has a clever trick: it sends the same advertisement packet sequentially across all three primary advertising channels (channels 37, 38, and 39).  Simultaneously, a scanning device will scan these three channels to look for advertising devices. This redundancy significantly increases the likelihood that at least one of those packets will get through cleanly and be picked up by a scanning device.</p> <p></p>"},{"location":"BLE_Background/#advertising-types","title":"Advertising Types","text":"<ul> <li> <p>Connectable vs. Non-Connectable: </p> <p>Determines whether the scanner can connect to the advertiser or not. To help us visualize the process, we'll refer to a power analysis graph from Nordic Semiconductor's online power profiler \u2014 it's a great way to understand the energy consumption and timing of different advertising types.  * Connectable:     The graph can be used to illustrate a connectable advertising event. You'll observe a repeating pattern: the device shows a distinct, dark green peak, indicating the transmission (TX) of an advertisement packet. Immediately following each TX peak, there's a short period represented by a lighter green segment, which indicates the receive (RX) mode. This RX window is crucial as the device is listening for any incoming connection requests. This TX-then-RX sequence repeats for each of the three primary advertising channels (37, 38, and 39), although the graph itself may not explicitly label the individual channel numbers on the timeline.       * Non-Connectable:     If we set the role to \"Advertising (TX only)\", the graph will exclusively show the TX (dark green) power consumption, with no associated RX (light green) activity. This clearly illustrates how a device solely focused on transmitting advertisements consumes power, without the added energy expenditure of listening for responses.     </p> </li> <li> <p>Scannable vs. Non-Scannable:      Determines if the advertiser accepts scan requests from a scanner     In our exemplar, we won't be covering scan requests.  </p> <ul> <li>Scan request and response:     During the discovery phase, if the scanner needs more information, it can send a scan request to the advertiser.     If the advertiser receives and accepts this scan request, it will reply with a scan response broadcast packet. These scan response packets are also sent over the advertising channels. It's worth noting that a scan response can sometimes be an empty broadcast packet.     This process allows the scanner to get additional information from the advertiser without needing to establish a full connection.       When an advertiser sends out scannable advertisements, it briefly opens its receiver (RX) on that same channel to listen for any scan requests from nearby devices. For example, after sending a packet on <code>channel 37</code>, it listens on <code>channel 37</code>; then after sending on <code>channel 38</code>, it listens on <code>channel 38</code>, and so on.       This allows it to listen for any scan requests from nearby devices. If it receives and accepts a scan request, it will then send a scan response.  </li> </ul> </li> <li> <p>Directed vs. undirected:     Determines whether advertisement packets are targeted to a specific scanner or not.     In this exemplar, we will focus solely on undirected advertising. While Bluetooth Low Energy (BLE) also supports directed advertising (where an advertiser specifically targets a known device), our examples and discussions will not cover this type of broadcast.</p> </li> </ul>"},{"location":"BLE_Background/#advertisement-packet","title":"Advertisement Packet","text":"<p>BLE advertisement packets are made up of several parts, but for a quick start guide like this, we'll focus on the most important one for getting your message out: the payload.  </p> <p>Generally, the payload of a BLE advertisement packet consists of two main parts: a 6-byte address and up to 31 bytes of advertising data (<code>AdvData</code>). The <code>AdvData</code> is specifically where you'll place the information you want to broadcast. Advertisement Data Structures*:     The Advertising Data portion of the advertisement packet isn't just a raw block of bytes; it's organized into multiple, smaller units called Advertisement Data Structures (AD Structures).     Each AD structure is self-contained and follows a specific format:     * Length Field: This field indicates the total length of that particular AD structure (including the Length, AD Type, and AD Data fields themselves).     * AD Type Field: This field specifies the type of data contained within this AD structure. For example, it could indicate that the following data represents a device's local name, a UUID, or manufacturer-specific data. Note that the most common AD type is 1 byte long.     * AD Data Field: This is where the actual information corresponding to the AD Type is placed.</p> <ul> <li>Commonly used AD structures<ul> <li>Complete local name (BT_DATA_NAME_COMPLETE): This is simply the device name, that the human user sees when scanning for nearby devices (via a smartphone, for instance).  </li> <li>Shortened local name (BT_DATA_NAME_SHORTENED): A shorter version of the complete local name.  </li> <li>Uniform Resource Identifier (BT_DATA_URI): Used to advertise a URI like website addresses (URLs).</li> <li>Service UUID: The Service Universally Unique Identifier is a number universally unique to a specific service. It can help scanners identify devices that are interesting to connect to. Different options are available here.</li> <li>Manufacturer Specific Data (BT_DATA_MANUFACTURER_DATA): This is a popular type that enables companies to define their own custom advertising data.</li> <li>Flags: 1-bit variables that can flag a certain property or operational mode of that device. While up to 8 flags can be set, we'll focus on a few commonly used ones:<ul> <li>BT_LE_AD_LIMITED: Sets LE Limited Discoverable Mode, used with connectable advertising to indicate to a central that the device is only available for a certain amount of time before the advertising times out.  </li> <li>BT_LE_AD_GENERAL: Indicates that the device is in LE General Discoverable Mode, meaning it's available for connection over a long period (effectively, no timeout).       </li> <li>BT_LE_AD_NO_BREDR: Specifies that the device does not support Classic Bluetooth (BR/EDR), only Bluetooth Low Energy (BLE).  </li> </ul> </li> </ul> </li> </ul>"},{"location":"BLEnd/","title":"What is BLEnd? Theoretical Foundations","text":"<p>Note: If you're completely new to BLE, please first read the document BLE Advertising and Scanning: What You Need to Know to ensure a clear understanding of the BLE scanning, advertising, and discovery process.</p> <p>In many common Bluetooth Low Energy (BLE) applications, a simple client-server model works perfectly well for device discovery. Typically, one device acts as a scanner (which becomes the Central after connection), while another device acts as an advertiser (becoming the Peripheral). This leads to a unidirectional discovery process, where the Central actively searches for Peripherals. A classic example is a phone scanning for a smart device advertising its presence; once found, a connection is established, and application-specific interactions follow.</p> <p>However, the BLEnd (Practical Continuous Neighbor Discovery for Bluetooth Low Energy) protocol deviates from this simpler \"one device scans, one device advertises\" setup. Instead, BLEnd is designed to manage the switching between advertising and scanning on all participating devices. This allows for a more dynamic and flexible discovery mechanism.</p> <p>This sophisticated approach makes BLEnd particularly well-suited for scenarios that lack a fixed master-slave hierarchy. Its primary application lies in environments such as Decentralized Peer-to-Peer Networks and Ad-Hoc Group Formation, where every device needs to be equally capable of finding and being found by others, fostering neighbor discovery without a predetermined central authority.</p>"},{"location":"BLEnd/#related-publication","title":"\ud83d\udcc4 Related Publication","text":"<p>Title: BLEnd: Practical Continuous Neighbor Discovery for Bluetooth Low Energy Authors: Julien, Christine and Liu, Chenguang and Murphy, Amy L and Picco, Gian Pietro   Published in: IPSN '17: The 16th International Conference on Information Processing in Sensor Networks URL: [BLEnd: Practical Continuous Neighbor Discovery for Bluetooth Low Energy] no link first</p> <p>If you use BLEnd in your work, please cite:</p> <pre><code>@inproceedings{julien2017blend,\n  title={BLEnd: practical continuous neighbor discovery for Bluetooth low energy},\n  author={Julien, Christine and Liu, Chenguang and Murphy, Amy L and Picco, Gian Pietro},\n  booktitle={Proceedings of the 16th ACM/IEEE International Conference on Information Processing in Sensor Networks},\n  pages={105--116},\n  year={2017},\n  organization={ACM}\n}\n</code></pre>"},{"location":"BLEnd/#source-code","title":"\ud83d\udcbb Source Code","text":"<p>The original BLEnd source code is hosted on GitHub: BLEnd_Nordic</p>"},{"location":"BLEnd/#blend-protocol-overview","title":"\ud83d\udcd6 BLEnd Protocol Overview","text":"<p>BLEnd segments time into discrete units called epochs. Within each epoch, devices switch between advertising and scanning roles. This rapid interleaving of activities enables all participating devices to both announce their presence and discover their neighbors efficiently.  </p> <p>The paper proposes three distinct algorithms for neighbor discovery: - Uni-directional Discovery (U-BLEnd) features a small duty cycle for low power consumption, with devices active for only just over half of each epoch, but it only guarantees uni-directional discovery.  - Full-epoch Bi-directional Discovery (F-BLEnd) keeps devices active throughout the entire epoch, utilizing a larger duty cycle to guarantee reliable bi-directional discovery.  - Efficient Bi-directional Discovery (B-BLEnd) builds upon U-BLEnd by dynamically adjusting its parameters to achieve efficient bi-directional discovery.</p> <p>Furthermore, the original paper offers detailed methods to calculate the ideal epoch length (E) and advertising interval (A). These calculations are tailored to specific application scenarios, taking into account crucial factors like:</p> <ul> <li>Device density: How many BLE devices are expected to be in close proximity?</li> <li>Power consumption requirements: How critical is battery life for the devices?</li> <li>Latency requirements: How quickly do devices need to discover each other?</li> </ul> <p>While the specifics of these optimization algorithms are complex and beyond the scope of this discussion, it's important to understand that epoch length (<code>E</code>) and advertising interval (<code>A</code>) are quantifiable parameters that can be derived using the proposed methods.</p> <p>We'll focus on U-BLEnd, as it provides the foundational understanding for BLEnd's approach to discovery. For those interested in the more optimized B-BLEnd, please refer to the original paper.</p>"},{"location":"BLEnd/#u-blend","title":"U-BLEnd","text":"<p>Within the U-BLEnd protocol, a device's operational cycle is structured into repeating epochs. As depicted in Figure 1, for the initial half of each epoch, the device actively engages its BLE radio for discovery. It first scans for a period, then transitions to advertising. During the latter half of the epoch, the radio transitions to a low-power stand-by state, conserving energy. </p> <p>Drawing from the optimization algorithms mentioned earlier, we can determine the system's required epoch length (<code>E</code>) and advertising interval (<code>A</code>). The scan duration is critically dependent on the advertising interval (<code>A</code>) to ensure reliable beacon reception. Since BLE broadcasts have a non-negligible duration (let's denote the beacon duration as <code>b</code>), a listener might only receive a partial beacon if its scan window isn't long enough. To counter this, the scan duration must be at least <code>A+b</code>. Furthermore, because BLE introduces a random slack to the application-specified advertising interval to avoid persistent collisions, the scan duration needs to be extended to account for this variability. Therefore, the scan window duration must be at least <code>A+b+s</code>, where <code>s</code> represents the maximum random slack added.</p> <p>To ensure reliable neighbor detection, the active portion of the epoch, defined as the time from the beginning of scanning to the end of the last beacon, is greater than half of the epoch. This design guarantees a temporal overlap in the active phases of independent devices, resulting in detection. It may also result in bi-directional discovery, as shown in Figure 1 for <code>Device A</code> and <code>Device C</code>.</p> <p> Figure 1: U-BLEnd Epoch Structure.</p>"},{"location":"demo/","title":"Demo Notebook","text":""},{"location":"demo/#introduction","title":"Introduction","text":"<p>This notebook provides a walkthrough of the example in the <code>demo</code> folder. These examples are designed to demonstrate how neighbor discovery works using BLE advertisements and scanning, with a particular focus on the BLEnd protocol What is BLEnd? Theoretical Foundations.</p> <p>For background information on BLE advertisement/scanning mechanisms and the BLEnd neighbor discovery protocol, please refer to the documentation BLE Advertising and Scanning: What You Need to Know.</p>"},{"location":"demo/#demo-implementation","title":"\u2699\ufe0f Demo Implementation","text":"<p>If you're unsure how to start and manage a timer, the document How to Use a Timer provides a quick start guide.</p> <p>In the demo_1, our application's timing and BLE operations are precisely managed by three distinct timers, each serving a specific role: </p> <ul> <li> <p><code>epoch_timer</code> defines the fixed duration of each epoch and controlling the repetition of these epochs. Crucially, this timer also initiates scanning at the beginning of every new epoch, ensuring the device periodically attempts to discover nearby nodes.  </p> </li> <li> <p><code>scan_timeout_timer</code> determines the duration of each scan operation and, upon its expiration, triggers the transition from scanning to advertising mode.</p> </li> <li> <p><code>adv_timeout_timer</code> controls the duration of our device's advertising periods.</p> </li> </ul>"},{"location":"demo/#initialization-setting-up-timing-parameters","title":"Initialization: Setting Up Timing Parameters","text":"<p>The timing parameters for the BLEnd application are configured during its initialization phase, specifically within the <code>blend_init()</code> function. This function takes the desired epoch length <code>E</code> and advertising interval <code>A</code> as inputs, from which the durations for scanning and advertising are derived. - Scan Duration:</p> <p>Formula: Scan Duration = <code>A+s+b</code></p> <ul> <li> <p>max_random_delay <code>s</code>: Represents the maximum random delay that might be applied to an advertising event.  <code>s</code> is assigned a fixed value of 10 milliseconds for the calculation since this random delay typically varies between 0 and 10 milliseconds.</p> </li> <li> <p>beacon_duration <code>b</code>: Represents the typical duration of a single BLE beacon transmission. For this implementation, <code>b</code> is assigned a fixed value of 5 milliseconds.</p> </li> <li> <p>Advertising Duration:</p> </li> </ul> <p>This is the crucial calculation that determines the overall length of the active part of the epoch (which includes both scanning and subsequent advertising). The goal is to ensure the last beacon transmission effectively finishes after the midpoint of the epoch (<code>E/2</code>).</p> <p>Logic:</p> <ul> <li> <p>First, we determine how many average advertising intervals (<code>A+5ms</code>) can fit within the portion of the first half-epoch remaining after accounting for an average random delay of 5ms.</p> </li> <li> <p>We then add 1 to this count to ensure at least one \"incomplete\" interval is considered.</p> </li> <li> <p>Multiply this advertising interval count\" by <code>A+5ms</code> to get a base active duration.</p> </li> <li> <p>Finally, we add 15ms (max_random_delay <code>s</code> + beacon_duration <code>b</code>) to this duration. This explicit addition ensures the end of the last beacon's transmission extends past the <code>E/2</code> mark.     <pre><code>static int epoch_period,adv_duration, scan_duration;\n/**\n* @brief Initializes the BLEnd module\n*\n* @param epoch_duration Duration of the epoch in milliseconds\n* @param adv_interval Advertising interval in 0.625 milliseconds\n*/\nvoid blend_init(int epoch_duration, int adv_interval)\n{\n    int adv_interval_count;\n    epoch_period = epoch_duration;\n      scan_duration = adv_interval* 0.625 +10 + 5;  //one adv_interval + 10ms random delay + 5ms for one advertising packet length\n    adv_interval_count = (epoch_duration/2 - scan_duration)/(adv_interval* 0.625 +5);   //an average random delay of 5ms\n    adv_interval_count+=1;    //one \"incomplete\" interval\n      adv_duration =adv_interval_count*(adv_interval* 0.625 +5)+15 ; // 15 ms for the last beacon's transmission \n    LOG_INF(\"BLEnd init: epoch_period %d ms, adv_duration %d ms, scan_duration %d ms\", epoch_period, adv_duration, scan_duration);\n}\n</code></pre></p> </li> </ul>"},{"location":"demo/#workflow-timer-driven-state-transitions","title":"Workflow: Timer-Driven State Transitions","text":"<p>The workflow unfolds as follows: - Application Start and Epoch Initialization:  </p> <p>Upon the BLEnd application's initiation, the <code>epoch_timer</code> is started. This timer is configured as a periodic timer with a cycle corresponding to the full epoch length (<code>E</code>). Crucially, its initial delay is set to <code>K_NO_WAIT</code>, which means the <code>epoch_timer_handler</code> is executed immediately after the epoch_timer is started.</p> <p>When the <code>epoch_timer_handler</code> is invoked (signaling the start of a new epoch):</p> <pre><code>- It immediately submits `scan_work` to the system workqueue. This work item, executed in a thread context, is responsible for starting the BLE scanning process.\n\n- Concurrently, it starts the `scan_timeout_timer`. This is configured as a one-shot timer with an initial delay equal to the predefined scan duration.\n</code></pre> <ul> <li>Scanning Timeout and Transition to Advertising:</li> </ul> <p>When the <code>scan_timeout_timer</code> expires (indicating the scan duration has passed), its handler is executed. </p> <p>Within this handler:</p> <pre><code>- It submits `scan_stop` to the workqueue to terminate the current scanning operation.\n\n- Immediately following, it submits `adv_work` to the workqueue, which then start the BLE advertising process.\n\n- Simultaneously, it starts the `adv_timeout_timer`. This is also a one-shot timer, whose initial delay is set to the intended advertising duration.\n</code></pre> <ul> <li>Advertising Timeout and Return to Stand-by:</li> </ul> <p>Upon the <code>adv_timeout_timer</code>'s expiration (signaling the end of the advertising duration), its handler is executed. In this handler:</p> <pre><code>- It performs the necessary actions to stop the BLE advertising.\n</code></pre> <p>Typically, at this point, the radio enters a low-power stand-by state until the next active period.</p> <ul> <li>Workflow Repetition:</li> </ul> <p>Since the <code>epoch_timer</code> is a periodic timer, it will continue to expire and trigger its handler at the completion of each epoch length (<code>E</code>). This inherent periodicity ensures that the entire sequence \u2014 scanning, transitioning to advertising, and then returning to an idle state \u2014 repeats seamlessly for every subsequent epoch, maintaining the defined operational cycle of the BLEnd node.</p>"},{"location":"demo/#advertising-and-scanning-implementation","title":"Advertising and Scanning Implementation","text":"<p>The files <code>advertiser_scanner.c</code> and <code>advertiser_scanner.h</code> contain the key structures and functions used to implement advertising and scanning in this example. These components are responsible for configuring BLE roles, scheduling radio operations, and handling received advertisement packets.</p> <p>The implementation makes use of official Zephyr Bluetooth APIs, particularly those defined under the GAP specification. To understand how these APIs are used and the associated parameter structures, please refer to Introduction to GAP.</p>"},{"location":"demo/#advertising","title":"Advertising","text":"<ul> <li> <p>Configuration:      In this demo, we focus solely on the advertising and scanning phases of BLE operation, without establishing any connections. Therefore, when configuring the <code>bt_le_adv_param *adv_param</code> structure, we set the options field to <code>BT_LE_ADV_OPT_NONE</code>, which means \"no options specified.\" As a result, the device performs non-connectable undirected advertising, effectively functioning as a beacon. This configuration allows other devices to scan and receive advertisements, but not initiate a connection.  <pre><code>    /* BLE Advertising Parameters variable */\nstatic struct bt_le_adv_param *adv_param =\n    BT_LE_ADV_PARAM(BT_LE_ADV_OPT_NONE, /* No options specified */\n            500, /* assign an initial value first */\n            500, /* assign an initial value first */\n            NULL); /* Set to NULL for undirected advertising */\n</code></pre></p> </li> <li> <p>Data:      The advertisement payload includes three main components: the Flags, the device name, and the Manufacturer Data. The Manufacturer Data field is particularly important in this demo. It contains a standard Company Identifier Code, followed by a custom-defined BLEnd ID, which signals that the device is actively participating in the BLEnd neighbor discovery protocol. (This BLEnd ID is defined in the original repository uploaded by the authors of the BLEnd protocol.) This setup allows scanning devices to recognize BLEnd participants based on their advertisement content, without requiring any additional interaction or connection.</p> <p><pre><code>/* Declare the Company identifier (Company ID) */\n#define COMPANY_ID_CODE 0x0059\n#define BLEND_IDENTIFIER  0xFE\ntypedef struct adv_mfg_data {\n    uint16_t company_code; /* Company Identifier Code. */\n    uint16_t blend_id;\n} adv_mfg_data_type;\n\n\n/* Define and initialize a variable of type adv_mfg_data_type */\nstatic adv_mfg_data_type adv_mfg_data = { COMPANY_ID_CODE, BLEND_IDENTIFIER };\n\n/* Declare the advertising packet */\nstatic const struct bt_data ad[] = {\n    /* Set the advertising flags */\n    BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR), // no BR/EDR support\n    /* Set the advertising packet data: device name and manufacturer data */\n    BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN), \n    BT_DATA(BT_DATA_MANUFACTURER_DATA, (unsigned char *)&amp;adv_mfg_data, sizeof(adv_mfg_data)),   \n\n};\n</code></pre> The device name included in the advertisement packet is configured via the<code>prj.conf</code> file, using the <code>CONFIG_BT_DEVICE_NAME</code> option. In this demo, we used \"NordicAdv\" as the device name, but feel free to customize it to anything you like. </p> <pre><code># Bluetooth LE\n# Include the Bluetooth LE stack in your project\nCONFIG_BT=y\n# Set the Bluetooth LE device name\nCONFIG_BT_DEVICE_NAME=\"NordicAdv\"\n</code></pre> </li> </ul> <p>We also recommend completing Exercise 2 of the same lesson. It provides a hands-on introduction to building and flashing applications to your development board using the nRF Connect SDK and associated tools. This step is especially helpful if you're new to Nordic's development workflow, as it familiarizes you with the process of compiling firmware and programming the device.  </p>"},{"location":"demo/#scanning","title":"Scanning","text":"<ul> <li>Configuration:  Since our advertisements are non-connectable and we do not use scan response data, the scanner is configured to operate in a non-intrusive, passive manner. Specifically, we disable automatic connection attempts and set the scan type to BT_SCAN_TYPE_SCAN_PASSIVE. This ensures that the scanner only listens for advertisements without sending scan requests or initiating connections, which aligns with the lightweight, broadcast-only nature of the BLEnd protocol.</li> <li>Scan filter:  Our scanner is capable of receiving a wide range of BLE advertisements from nearby devices. However, how can we tell which advertisement packets are actually relevant to our application? To address this, we apply a filter to the scanner, allowing it to identify and process only the packets we\u2019re interested in. In this demo, the filter is used to detect advertisement packets that contain a specific Manufacturer Data pattern. This ensures that the scanner only responds to devices actively participating in the BLEnd protocol.  First, we enable the scanning module and filtering functionality through the <code>prj.conf</code> file. Specifically, we activate the scan filter feature and configure the type and number of filters to be used. In this demo, we define one Manufacturer Data filter, which allows the scanner to selectively process advertisement packets that contain a specific payload structure corresponding to the BLEnd protocol.</li> </ul> <pre><code># Enable the BLE Scan module: one maunfacturer data filter\nCONFIG_BT_SCAN=y\nCONFIG_BT_SCAN_FILTER_ENABLE=y\nCONFIG_BT_SCAN_MANUFACTURER_DATA_CNT=1\n</code></pre> <p>During the initialization of the scan module, we add a scan filter and enable it using the Manufacturer Data filter mode. Specifically, we register the expected pattern (containing the Company Identifier Code and BLEnd ID) and activate the filter with the mode <code>BT_SCAN_MANUFACTURER_DATA_FILTER</code>. This ensures that only advertisement packets matching our defined Manufacturer Data format will trigger further processing.   </p> <ul> <li> <p>Expected pattern:    <pre><code>/* Declare the Company identifier (Company ID) */\n#define COMPANY_ID_CODE 0x0059\n#define BLEND_IDENTIFIER  0xFE\ntypedef struct adv_mfg_data {\n    uint16_t company_code; /* Company Identifier Code. */\n    uint16_t blend_id; /* sequence number */\n} adv_mfg_data_type;\n\n\n/* Define and initialize a variable of type adv_mfg_data_type */\nstatic adv_mfg_data_type adv_mfg_data = { COMPANY_ID_CODE, BLEND_IDENTIFIER };\n\n\n// Define the bt_scan_manufacturer_data struct for the filter\n// It holds a pointer to your filter data and its length\nstatic struct bt_scan_manufacturer_data mfg_filter = {\n    .data = (uint8_t *)&amp;adv_mfg_data,\n    .data_len = sizeof(adv_mfg_data),\n};\n</code></pre></p> </li> <li> <p>void scan_init(void):  <pre><code>int err;\nuint8_t filter_mode = 0;\n\nerr = bt_scan_filter_add(BT_SCAN_FILTER_TYPE_MANUFACTURER_DATA,&amp;mfg_filter );\nif (err) {\n    LOG_ERR(\"filter cannot be added (err %d\", err);\n    return;\n}\nfilter_mode |= BT_SCAN_MANUFACTURER_DATA_FILTER;\n\nerr = bt_scan_filter_enable(filter_mode, false);\nif (err) {\n    LOG_ERR(\"Filters cannot be turned on (err %d)\", err);\n    return;\n}\n</code></pre></p> </li> </ul>"},{"location":"demo/#demo-results","title":"Demo Results \ud83d\udce1","text":"<p>Before running this demo, make sure you have completed the necessary setup steps. We recommend starting with Lesson 1, Exercise 1 of the official nRF Connect SDK Fundamentals tutorial provided by Nordic Semiconductor. This exercise walks you through installing the required development tools, setting up your environment.</p>"},{"location":"demo/#build-and-flash","title":"Build and Flash","text":"<p>In the Build Configuration page, select the appropriate board target based on the BLE hardware you are using. In our case, we use the nrf52832dk development kit. For the configuration, choose the <code>prj.conf</code> file as the active configuration. No additional settings are required. Once this is done, simply click <code>Generate and Build</code> to compile the application.  </p> <p>Once the build completes successfully, you should see a message similar to the one shown in the screenshot below in the terminal.</p> <p> </p> <p>After that, connect your development board to the computer via USB. The nRF Connect for VS Code should automatically detect the connected device. Simply click Flash to program the board with the generated build files.</p> <p> </p>"},{"location":"demo/#observed-results-from-the-demo","title":"Observed Results from the Demo","text":"<p>There are two main ways to observe the behavior of the running demo: LED indicators and the RTT (Real-Time Terminal) output.</p> <p>We assign LED1, LED2 and LED3 to indicate BLEnd running, scanning and advertising activity, respectively. When the device is actively advertising or scanning, the corresponding LED will turn on, providing a simple visual confirmation of the current state.</p> <p>In addition, the demo uses the Logger module, which prints messages to the terminal via RTT. This output provides more detailed runtime information, such as advertising/scanning events and received packets, making it easier to debug and understand the protocol flow.</p>"},{"location":"demo/#led-indicators","title":"LED indicators","text":"<p>The blinking LED1 indicate that the device is actively running the BLEnd protocol. </p> <p></p> <p>At the beginning of each epoch, the device first enters the scanning phase, during which LED2 is turned on. This indicates that the device is actively listening for nearby BLE advertisements as part of the BLEnd neighbor discovery process.</p> <p></p> <p>After the scanning phase completes, the device transitions into the advertising phase. At this point, LED2 turns off and LED3 turns on, signaling that the device is now broadcasting its own BLE advertisement to announce its presence to nearby nodes.</p> <p></p> <p>After the advertising phase ends, there is a short idle period that lasts for approximately half of the epoch. During this time, only LED1 blinks, while both LED2 and LED3 remain off. This indicates that the device is still running the BLEnd protocol, but is not performing any active radio operations (i.e., neither scanning nor advertising). </p>"},{"location":"demo/#rtt-terminal","title":"RTT terminal","text":"<p>After flashing the board, connect to the device\u2019s RTT interface to monitor log output. </p> <p> </p> <p>Once connected, you will see log messages printed in the RTT terminal, providing real-time feedback from the application. These messages include status updates for advertising and scanning, filtered packet detection, and other useful debug information.</p> <p></p>"},{"location":"demo_connect/","title":"Demo-Connect Notebook","text":""},{"location":"demo_connect/#introduction","title":"Introduction","text":"<p>In the previous example from the <code>demo</code> folder, you learned how to configure advertising and scanning to enable device discovery using BLE. In this example, we take it a step further: once devices discover each other, they proceed to establish a connection and demonstrate basic data exchange through a custom service.</p> <p>Unlike the previous demo, this example is presented as a challenge, requiring some self-guided learning. To prepare, we highly recommend reading Lesson 4 from the Nordic Bluetooth Low Energy Fundamentals course. It provides essential background on how GATT (Generic Attribute Profile) services and characteristics are used to structure and transfer data in a BLE connection.</p>"},{"location":"demo_connect/#led-button-service-lbs","title":"LED Button Service (LBS)","text":"<p>While Lesson 4, Exercises 1 and 2 in the Nordic tutorial provide a detailed walkthrough of configuring an LBS server, including characteristic read/write operations and sending indications, their example focuses on interaction between a BLE device (as the server) and a mobile app (as the client).</p> <p>In contrast, this <code>demo_connect</code> is designed to demonstrate device-to-device communication, where both the client and server are embedded BLE devices. To simplify the setup, the server only provides a basic Button Characteristic, and the emphasis is placed on client-side configuration, including service discovery, characteristic subscription, and handling received indications.</p> <p>The goal is to show how two BLE-enabled devices can autonomously discover each other, establish a connection, and exchange data using GATT, without relying on external apps or user interaction via smartphones.</p> <p>In this setup:</p> <ul> <li> <p>The server provides a Button Characteristic, which reflects the state of a physical button on the device.</p> </li> <li> <p>The client first performs GATT service discovery to locate the LBS on the server. Once the service is found, the client subscribes to the Button Characteristic.</p> </li> <li> <p>From that point on, whenever the server detects a change in the button state, it sends an indication to the client. </p> </li> <li> <p>This allows the client to receive real-time updates whenever the server\u2019s button is pressed or released, illustrating how BLE GATT indications can be used for efficient event-driven communication.</p> </li> </ul> <p>Due to the higher memory requirements of the central role, please make sure to use two BLE development boards that support central functionality.</p> <p>Build and flash the <code>demo_connect</code> application onto both devices. Once running, each device will first execute the BLEnd protocol to discover nearby peers through advertising and scanning. After discovery, one device will initiate a connection to the other and proceed with GATT-based service interaction, completing the full discovery-and-connect flow.</p>"},{"location":"demo_connect/#configuration","title":"Configuration","text":"<p>In the <code>prj.conf</code> file, we enable the required Bluetooth GAP roles and also limit the device to a single active connection at a time, which simplifies connection management.</p> <p><pre><code># enable BLE GAP roles\nCONFIG_BT_PERIPHERAL=y\nCONFIG_BT_CENTRAL=y\nCONFIG_BT_MAX_CONN=1\n</code></pre> Since the central device will perform GATT service discovery and handle characteristics, we enable <code>CONFIG_BT_GATT_CLIENT</code> and <code>CONFIG_BT_GATT_DM</code> to support the client role and allow dynamic discovery of services on the peer device. Because GATT discovery and central operations require more memory, we also set <code>CONFIG_HEAP_MEM_POOL_SIZE=2048</code> to ensure the application has sufficient dynamic memory during runtime.</p> <pre><code>CONFIG_BT_GATT_CLIENT=y\nCONFIG_BT_GATT_DM=y\nCONFIG_HEAP_MEM_POOL_SIZE=2048\n</code></pre>"},{"location":"demo_connect/#led-indicators","title":"LED indicators","text":"<p>As in the previous demo, LED2 and LED3 are used to indicate the scanning and advertising phases, respectively. In this example, we also utilize LED1 and LED4 to indicate the device\u2019s role after a connection is established:</p> <p>LED1 turns on if the device is acting as a peripheral.</p> <p>LED4 turns on if the device is acting as a central.</p> <p>In the BLE GATT service, the peripheral functions as the server, while the central acts as the client.</p> <p>For the central/client device, LED1 serves an additional purpose: it reflects the button state received from the server via indications. When a \"button pressed\" indication is received, LED1 turns on. When a \"button released\" message is received, LED1 turns off. This provides real-time, visible feedback that the central device is successfully receiving and interpreting the server's characteristic updates.</p>"},{"location":"demo_connect/#server","title":"Server","text":"<p>The files <code>my_lbs.c</code> and <code>my_lbs.h</code> contain the code for the LBS server, adapted from Lesson 4, Exercises 1 and 2 in the Nordic tutorial. Since the implementation closely follows the original example, we won\u2019t go into detail here.</p> <p>As a quick test, you can build and flash the server code onto a development board and interact with it using a mobile app (e.g., nRF Connect for Mobile). This allows you to verify that the Button Characteristic is functioning correctly before proceeding with full device-to-device interaction.</p> <p>To demonstrate the server functionality, you can use the nRF Connect for Mobile app as the client.   </p> <ul> <li> <p>Scan for nearby BLE devices in the app. Look for the device named <code>my_LBS</code>. Once found, connect to the device.   </p> </li> <li> <p>The app will automatically discover the services provided by the server. Locate the Button Characteristic, and tap the button outlined in red to subscribe to indications.  </p> <p></p> </li> <li> <p>Now, when you press the physical button (Button 1) on the development board, the server sends a Button State indication, which is received and displayed by the mobile app. </p> <p> </p> </li> </ul>"},{"location":"demo_connect/#client","title":"Client","text":"<p>From the interaction between the server and the mobile app, we can clearly see the key responsibilities of a central device in this context:</p> <ol> <li> <p>Scan for the target peripheral device and initiate a connection once the device is discovered.</p> </li> <li> <p>Perform service discovery to locate the desired GATT service and characteristics.</p> </li> <li> <p>Subscribe to indications from the Button State characteristic to receive updates.</p> </li> </ol> <p>These same steps will be implemented in the client-side firmware when setting up communication between two development boards.</p>"},{"location":"demo_connect/#initiate-a-connection","title":"Initiate a connection","text":"<ul> <li> <p>Advertiser:     First, we configure the device to broadcast connectable advertisements instead of non-connectable beacons, allowing other devices to initiate a connection once discovered.   </p> <p>in <code>demo_connect/src/advertiser_scanner.c</code> <pre><code>    /* BLE Advertising Parameters variable */\n    static struct bt_le_adv_param *adv_param =\n        BT_LE_ADV_PARAM(BT_LE_ADV_OPT_CONNECTABLE, /* connectable */\n                500, /* assign an initial value first */\n                500, /* assign an initial value first */\n                NULL); /* Set to NULL for undirected advertising */\n</code></pre> - Scanner: On the scanning side, we continue to use a Manufacturer Data filter within the scan module. When a device detects an advertisement that matches this filter, it immediately initiates a connection to the advertising peer. This enables automatic pairing between BLEnd-enabled devices without user interaction.   </p> <p>in <code>demo_connect/src/advertiser_scanner.c</code> <pre><code>    struct bt_scan_init_param scan_init = {\n    .scan_param = &amp;my_scan_param,\n    .connect_if_match = true,\n    };\n</code></pre> - Connection:  The functions and structures used for connection management are detailed in the documentation Introduction to GAP.   </p> <p>In <code>main.c</code>, we declare a static pointer to hold the active connection. This variable is used throughout the application to track the current BLE connection and interact with the connected peer. We also register connection callbacks using a <code>bt_conn_cb</code> structure. These callbacks handle key connection events such as connection established, disconnected. Registering these callbacks allows the application to respond to connection state changes appropriately.</p> <p><pre><code>   static struct bt_conn *default_conn = NULL;\n   struct bt_conn_cb connection_callbacks = {\n        .connected = on_connected,\n        .disconnected = on_disconnected,\n    };\n    int main(void){\n        ...\n        // Register the connection callbacks \n        bt_conn_cb_register(&amp;connection_callbacks);\n        ...\n    }\n</code></pre> Next, we implement the connection and disconnection callback functions to manage the BLE connection lifecycle.</p> <ul> <li>Inside the connection callback function, we first stop the BLEnd protocol because <code>CONFIG_BT_MAX_CONN</code> is set to 1 in the <code>prj.conf</code> file. Then, we increase the reference count to safely keep track of the active connection, followed by retrieving detailed connection information. The <code>info.role</code> field indicates whether the device is currently acting as a central or peripheral. Based on this role, we turn on the corresponding LED to visually indicate the device\u2019s role after the connection is established.     <pre><code>#define CONN_LED_PERIPHERAL DK_LED1\n#define CONN_LED_CENTRAL DK_LED4\nstatic void on_connected(struct bt_conn *conn, uint8_t err)\n{\n    int err_dm;\n    struct bt_conn_info info = {0};\n    /*  check errors ... */\n\n    blend_stop();\n\n    default_conn = bt_conn_ref(conn);\n    err_dm = bt_conn_get_info(default_conn, &amp;info);\n    if (err_dm) {\n        LOG_ERR(\"Failed to get connection info %d\\n\", err);\n        return;\n    }\n    if (info.role == BT_CONN_ROLE_PERIPHERAL) {\n            LOG_INF(\"Connected: BT_CONN_ROLE_PERIPHERAL\\n\");\n        dk_set_led_on(CONN_LED_PERIPHERAL);\n    }\n    if (info.role == BT_CONN_ROLE_CENTRAL) {\n        LOG_INF(\"Connected: BT_CONN_ROLE_CENTRAL\\n\");\n        dk_set_led_on(CONN_LED_CENTRAL);\n        /*  service discovery (next step) ... */\n    }      \n}\n</code></pre></li> <li>In the disconnect callback function, we log the reason for disconnection, unreference the connection object and set <code>default_conn</code> back to <code>NULL</code> since there is no active connection anymore. After that, we restart the BLEnd protocol to resume neighbor discovery following the disconnection.     <pre><code>static void on_disconnected(struct bt_conn *conn, uint8_t reason)\n{\n    LOG_INF(\"Disconnected (reason %u)\\n\", reason);\n\n    dk_set_led_off( CONN_LED_CENTRAL);\n    dk_set_led_off(CONN_LED_PERIPHERAL);\n\n    bt_conn_unref(default_conn);\n    default_conn = NULL;\n\n    blend_start();\n}\n</code></pre></li> </ul> </li> </ul> <p>We first define a discovery callback structure: <code>struct bt_gatt_dm_cb discovery_cb</code>. This structure contains three callback functions that will be triggered during the GATT discovery process: one when the target service is found, one when the service is not found, and one for handling errors. In these callbacks, we simply log the service discovery states: \"Service found\", \"Service not found\", or \"Error while discovering GATT database\" along with the corresponding error code. <pre><code>static void discovery_complete(struct bt_gatt_dm *dm,\n                   void *context)\n{\n\n    int err;\n    LOG_INF(\"Service found\");\n}\n\nstatic void discovery_service_not_found(struct bt_conn *conn,\n                    void *context)\n{\n    LOG_INF(\"Service not found\\n\");\n}\n\nstatic void discovery_error(struct bt_conn *conn,\n                int err,\n                void *context)\n{\n    LOG_ERR(\"Error while discovering GATT database: (%d)\\n\", err);\n}\n\nstruct bt_gatt_dm_cb discovery_cb = {\n    .completed         = discovery_complete,\n    .service_not_found = discovery_service_not_found,\n    .error_found       = discovery_error,\n};\n</code></pre></p> <p>In the <code>on_connect</code> callback, the central device initiates GATT service discovery using: <pre><code>static void on_connected(struct bt_conn *conn, uint8_t err){\n    int err_dm;\n    /* ... */\n    if (info.role == BT_CONN_ROLE_CENTRAL) {\n                LOG_INF(\"Connected: BT_CONN_ROLE_CENTRAL\\n\");\n                dk_set_led_on(CONN_LED_CENTRAL);\n                /*  service discovery  */\n                err_dm = bt_gatt_dm_start(default_conn,\n                          BT_UUID_LBS,\n                          &amp;discovery_cb,\n                          NULL);\n            }       \n}\n</code></pre> This function starts the discovery process for the LBS on the connected peripheral device. The parameters passed are:</p> <ul> <li> <p><code>default_conn</code>: the active connection to the peer device,</p> </li> <li> <p><code>BT_UUID_LBS</code>: the UUID of the service to discover,</p> </li> <li> <p><code>discovery_cb</code>: a struct containing callback functions to be triggered during discovery,</p> </li> <li> <p><code>NULL</code>: a user-defined context to be passed to callback functions. Set to <code>NULL</code> here.</p> </li> </ul>"},{"location":"demo_connect/#service-discovery","title":"Service Discovery","text":""},{"location":"demo_connect/#discovery-complete","title":"Discovery Complete","text":"<p>After the GATT service discovery completes, we proceed to assign the discovered handles to our client structure and subscribe to the Button Characteristic indications. Finally, we release the discovery manager\u2019s resources using <code>bt_gatt_dm_data_release</code> to free memory allocated during the discovery process. <pre><code>static void discovery_complete(struct bt_gatt_dm *dm,\n                   void *context)\n{\n\n    int err;\n    LOG_INF(\"Service found\");\n\n    my_lbs_client_handles_assign(dm, &amp;bt_my_client);\n\n    err = my_lbs_client_button_subscribe(&amp;bt_my_client, my_lbs_indicate_cb);\n    if (err) {\n        printk(\"Could not subscribe to LBS button characteristic (err %d)\\n\",\n               err);\n    }\n\n    err = bt_gatt_dm_data_release(dm);\n    if (err) {\n        LOG_ERR(\"Could not release the discovery data (err %d)\\n\", err);\n    }\n}\n</code></pre></p> <p>The client-related functions and structures are defined in the <code>my_lbs_client.c</code> and <code>my_lbs_client.h</code> files.</p> <ul> <li> <p>Assign the discovered handles:      The function <code>my_lbs_client_handles_assign</code> is responsible for extracting and storing relevant GATT handles (such as the characteristic value handle and CCCD handle) from a discovered LBS, using the GATT Discovery Manager (<code>bt_gatt_dm</code>). It maps these handles into the local <code>my_lbs_client</code> structure so the client can interact with the LBS (e.g., subscribe to button state changes).     Parameters: </p> <ul> <li> <p><code>my_lbs_client</code>: This structure is defined in <code>my_lbs_client.h</code>, which holds necessary state and data for interacting with a remote LBS on a BLE peripheral. It is used by the LBS client application to store the BLE connection, characteristic handles, and internal state for subscribing to button state indications.</p> </li> <li> <p><code>dm</code>: This pointer is a reference to a GATT Discovery Manager <code>bt_gatt_dm</code> instance, which contains the results of a completed service discovery procedure on a connected BLE peripheral.</p> </li> </ul> <p>In <code>my_lbs_client.h</code> <pre><code>    struct my_lbs_client_button {\n        /** Value handle. */\n        uint16_t handle;\n\n        /** Handle of the characteristic CCC descriptor. */\n        uint16_t ccc_handle;\n\n        /** GATT subscribe parameters for indicate. */\n        struct bt_gatt_subscribe_params indicate_params;\n\n        /** Indicate callback. */\n        my_lbs_client_indicate_cb indicate_cb;\n    };\n\n    struct my_lbs_client {\n        /** Connection object. */\n        struct bt_conn *conn;\n\n        /** LBS button characteristic. */\n        struct my_lbs_client_button button_char;\n\n        /** Internal state. */\n        atomic_t state;\n    };\n</code></pre></p> <p>In <code>my_lbs_client.c</code> <pre><code>int my_lbs_client_handles_assign(struct bt_gatt_dm *dm, struct my_lbs_client *my_lbs_c)\n{\n    // Get the primary service attribute and value\n    const struct bt_gatt_dm_attr *gatt_service_attr = bt_gatt_dm_service_get(dm);\n    const struct bt_gatt_service_val *gatt_service = bt_gatt_dm_attr_service_val(gatt_service_attr);\n\n    // Declare variables for characteristic and descriptor attributes\n    const struct bt_gatt_dm_attr *gatt_chrc;\n    const struct bt_gatt_dm_attr *gatt_desc;\n\n    // Check for null pointers\n    if (!dm || !my_lbs_c) {\n        return -EINVAL;\n    }\n\n    // Verify that the discovered service is the expected LBS\n    if (bt_uuid_cmp(gatt_service-&gt;uuid, BT_UUID_LBS)) {\n        return -ENOTSUP;  // Service not supported\n    }\n\n    LOG_DBG(\"Getting handles from my_lbs service.\");\n\n    // Reinitialize the client structure to clear any previous state\n    my_lbs_reinit(my_lbs_c);\n\n    // Find the LBS-BUTTON characteristic by UUID\n    gatt_chrc = bt_gatt_dm_char_by_uuid(dm, BT_UUID_LBS_BUTTON);\n    if (!gatt_chrc) {\n        LOG_ERR(\"No LBS characteristic found.\");\n        return -EINVAL;\n    }\n\n    // Find the characteristic value descriptor (i.e., the actual value handle)\n    gatt_desc = bt_gatt_dm_desc_by_uuid(dm, gatt_chrc, BT_UUID_LBS_BUTTON);\n    if (!gatt_desc) {\n        LOG_ERR(\"No LBS-BUTTON characteristic value found.\");\n        return -EINVAL;\n    }\n\n    // Store the value handle in the client structure\n    my_lbs_c-&gt;button_char.handle = gatt_desc-&gt;handle;\n\n    // Find the CCCD (Client Characteristic Configuration Descriptor)\n    gatt_desc = bt_gatt_dm_desc_by_uuid(dm, gatt_chrc, BT_UUID_GATT_CCC);\n    if (!gatt_desc) {\n        LOG_ERR(\"No LBS-BUTTON CCC descriptor found.\");\n        return -EINVAL;\n    }\n\n    // Store the CCC handle in the client structure\n    my_lbs_c-&gt;button_char.ccc_handle = gatt_desc-&gt;handle;\n\n    LOG_DBG(\"LBS-BUTTON characteristic found\");\n\n    // Store the BLE connection reference for future operations\n    my_lbs_c-&gt;conn = bt_gatt_dm_conn_get(dm);\n\n    return 0;  // Success\n}\n</code></pre></p> </li> <li> <p>Subscribe to the Button Characteristic:      The purpose of the function <code>my_lbs_client_button_subscribe</code> is to allow the client device to subscribe to indication messages from a remote BLE peripheral, so it can be indicated when the button state changes.</p> <p>The function first validates the input client structure and callback, then uses <code>atomic_test_and_set_bit</code> to check whether indication has already been enabled (<code>INDICATE_ENABLED</code>).</p> <p>It then sets the subscription parameters, including <code>ccc_handle</code>, <code>value_handle</code>, <code>value</code> (set to <code>BT_GATT_CCC_INDICATE</code>), and the <code>notify</code> callback. It also sets the <code>BT_GATT_SUBSCRIBE_FLAG_VOLATILE</code> flag to ensure the subscription is re-established after disconnection.</p> <p>Finally, it calls <code>bt_gatt_subscribe</code> to subscribe to the indication and returns the result.   </p> <p>Parameters:  - <code>my_lbs_c</code>: A pointer to the LBS client structure, which holds connection and characteristic information.   - <code>dicate_cb</code>: A user-provided callback function that will be invoked when an indication is received from the button characteristic.    </p> <pre><code>int my_lbs_client_button_subscribe(struct  my_lbs_client *my_lbs_c,\n                    my_lbs_client_indicate_cb indicate_cb)\n{\n    int err;\n\n    // Create a local pointer alias to simplify access to the indication parameters\n    struct bt_gatt_subscribe_params *params = &amp;my_lbs_c-&gt;button_char.indicate_params;\n\n    if (!my_lbs_c || !indicate_cb) {\n        return -EINVAL;\n    }\n\n    if (atomic_test_and_set_bit(&amp;my_lbs_c-&gt;state, INDICATE_ENABLED)) {\n        LOG_INF(\"LBS-BUTTON characterisic indication already enabled.\");\n        // return -EALREADY;\n    }\n\n    // Set the required GATT subscription parameters\n    my_lbs_c-&gt;button_char.indicate_cb = indicate_cb;\n    params-&gt;ccc_handle = my_lbs_c-&gt;button_char.ccc_handle;\n    params-&gt;value_handle = my_lbs_c-&gt;button_char.handle;\n    params-&gt;value= BT_GATT_CCC_INDICATE;\n    params-&gt;notify = my_lbs_button_indicate;\n\n    atomic_set_bit(params-&gt;flags, BT_GATT_SUBSCRIBE_FLAG_VOLATILE);\n\n    //subscribe to the characteristic\n    err = bt_gatt_subscribe(my_lbs_c-&gt;conn, params);\n    if (err) {\n        atomic_clear_bit(&amp;my_lbs_c-&gt;state, INDICATE_ENABLED);\n        LOG_ERR(\"Subscribe to characteristic failed\");\n    } else {\n        LOG_DBG(\"Subscribed to  LBS-BUTTON characteristic\");\n    }\n\n    return err;\n}\n</code></pre> </li> </ul>"},{"location":"demo_connect/#demo-results","title":"Demo Results \ud83d\udce1","text":"<p>Now, build and flash the <code>demo_connect</code> application onto both boards. After a short time, BLEnd will connect the two devices automatically. The peripheral device will turn on LED1, while the central device will turn on LED4 to indicate their respective roles.   </p> <p></p> <p>When you press Button 1 on the peripheral board, LED1 on the central board will turn on. Releasing Button 1 on the peripheral will turn LED1 off on the central, reflecting the button state change via BLE indications.   </p> <p></p> <p>We can also open the RTT (Real-Time Terminal) on both devices to observe more detailed logs. For example, if we reset one device, the other will log the disconnection reason 8 (The supervision timeout has expired). Then, both devices automatically start the BLEnd protocol. Once a neighbor is discovered, the scanner initiates a connection, performs service discovery, and starts receiving indications after the connection is established.  </p> <p></p>"},{"location":"introduction_to_GAP/","title":"Intro to GAP","text":""},{"location":"introduction_to_GAP/#introduction-to-zephyr-api-generic-access-profile-gap","title":"Introduction to Zephyr API: Generic Access Profile (GAP)","text":"<p>Zephyr OS is an open-source real-time operating system designed for resource-constrained devices. In Zephyr, the <code>zephyr/bluetooth/gap.h</code> header file provides the essential Application Programming Interfaces (APIs) that applications use to interact with the Bluetooth Generic Access Profile (GAP). GAP defines how Bluetooth devices discover each other, connect, and communicate in a secure manner. Understanding this header is crucial for developing any Zephyr-based Bluetooth application.</p>"},{"location":"introduction_to_GAP/#core-concepts","title":"Core Concepts","text":"<ul> <li> <p>Roles: Bluetooth GAP defines various roles a device can assume, primarily including:</p> <ul> <li>Broadcaster: A device that only sends advertising data (e.g., a beacon).</li> <li>Observer: A device that only scans for advertising data.</li> <li>Central: A device that scans for and connects to peripheral devices (e.g., a smartphone connecting to Bluetooth headphones).</li> <li>Peripheral: A device that can be connected to by a central device (e.g., Bluetooth headphones).</li> </ul> </li> <li> <p>Operations &amp; Device Interactions</p> <ul> <li>Advertising &amp; Scanning:<ul> <li>Advertising: Devices transmit advertising packets containing information like their name and service UUID(Universally Unique Identifier), making themselves discoverable. This is typically performed by Peripheral and Broadcaster roles.</li> <li>Scanning: Devices listen for and parse advertising packets sent by other devices. This is a primary action for Central and Observer roles.</li> </ul> </li> <li>Connection: Once devices discover each other and aim to communicate, they establish and manage a connection. GAP handles the lifecycle of these connections. This primarily involves Central and Peripheral roles.</li> </ul> </li> <li> <p>Address Types: Bluetooth devices use addresses to uniquely identify themselves. Common address types include:</p> <ul> <li>Public Address: A globally unique IEEE EUI-48 address. It's predominantly associated with Classic Bluetooth, also known as BR/EDR (Basic Rate/Enhanced Data Rate) connections.</li> <li>Random Address: Widely used in Bluetooth Low Energy (BLE) </li> </ul> </li> </ul>"},{"location":"introduction_to_GAP/#key-api-functions-from-zephyrbluetoothgaph-and-related","title":"Key API Functions (from <code>zephyr/bluetooth/gap.h</code> and related)","text":"<p>While <code>zephyr/bluetooth/gap.h</code> serves as the foundational header for the GAP, defining its core structures, roles, and macros, the functional APIs for specific GAP operations. Actual GAP operations are often performed by combining APIs from <code>bluetooth/bluetooth.h</code> and are often modularized into dedicated headers. For instance, <code>scan.h</code> provides functions for device discovery, and <code>conn.h</code> handles active connection management, both building upon the underlying GAP definitions established in gap.h.   Usful links: Nordic: https://docs.nordicsemi.com/bundle/zephyr-apis-latest/page/group_bt_gap.html Zephyr: https://docs.zephyrproject.org/apidoc/latest/group__bt__gap.html</p> <p>Here are some common GAP-related operations you'll frequently encounter in Zephyr Bluetooth development:  </p>"},{"location":"introduction_to_GAP/#1-initializing-the-bluetooth-stack","title":"1. Initializing the Bluetooth Stack","text":"<p><pre><code>int bt_enable   (   bt_ready_cb_t   cb  )   \n</code></pre> The bt_enable() function is the essential starting point for any Bluetooth application in Zephyr. You must call this function before attempting any other Bluetooth operations that require communication with the local Bluetooth hardware. * Parameters cb:     Give it a callback function: Your program continues running, and Zephyr tells that function when Bluetooth is ready. This is what we call asynchronous operation \u2013 tasks happening in the background without blocking your main program flow.     Give it NULL: Your program pauses and waits until Bluetooth is ready before moving on. This is a synchronous operation. </p> <ul> <li>Returns Zero on success or (negative) error code otherwise.</li> <li>Example <pre><code># in prj.conf file\n# Logger module\nCONFIG_LOG=y\n#  Include the Bluetooth LE stack in your project\nCONFIG_BT=y\n</code></pre> <pre><code># in .c file\n#include &lt;zephyr/bluetooth/bluetooth.h&gt;\n#include &lt;zephyr/bluetooth/gap.h&gt; \nint err;\n\n    /* Enable the Bluetooth LE stack */\n    err = bt_enable(NULL);\n    if (err) {\n        LOG_ERR(\"Bluetooth init failed (err %d)\\n\", err);\n        return; // Handle error appropriately\n    }\n\n    LOG_INF(\"Bluetooth initialized\\n\");\n</code></pre></li> </ul>"},{"location":"introduction_to_GAP/#2-configuring-advertisement","title":"2. Configuring Advertisement","text":"<p>The functions described below are central to implementing BLE advertising in your applications. Before diving into their specifics, we strongly recommend you first read our BLE Advertising and Scanning: What You Need to Know document. This will give you the essential foundational knowledge of how BLE advertising works, which is crucial for understanding these functions.</p>"},{"location":"introduction_to_GAP/#related-structures","title":"Related Structures","text":"<ul> <li>struct bt_le_adv_param: specifies what fields (variables) are needed to describe Bluetooth Low Energy (LE) advertising parameters.     We can use the helper maco BT_LE_ADV_PARAM() to initialize an instance of the bt_le_adv_param structure:     <ul> <li>Advertising options:      Specific macros are used to configure advertising options. These options consist of configuration bits that control the behavior of the advertising process.     For example:<ul> <li>BT_LE_ADV_OPT_NONE:   simply means \"don't auto-configure any behavior\" \u2014 but it doesn't prevent you from manually adding things like the name.</li> <li>BT_LE_ADV_OPT_CONNECTABLE: lets other devices connect to you.</li> <li>BT_LE_ADV_OPT_USE_NAME: includes the device name in the advertising data.</li> </ul> </li> <li>Advertising interval:<ul> <li>Minimum advertising interval:  is calculated as N\u00d70.625 milliseconds and must be less than or equal to the maximum advertising interval.</li> <li>Maximum advertising interval:   is also calculated as N\u00d70.625 milliseconds and must be greater than or equal to the minimum advertising interval.   </li> <li>For both the minimum and maximum intervals, the value of N must fall between 32 and 16384. This means the advertising interval can range from 20 milliseconds to 10.24 seconds. The API provides convenient, ready-to-use options, rather than forcing you to always manually calculate and input the raw numerical value of 'N'.</li> <li>the actual advertising interval used by the BLE device will be a random value chosen by the BLE controller within that specified range (Min to Max), plus a small random delay. Some advanced BLE stacks or applications might even dynamically adjust the advertising interval within the min/max range.  </li> </ul> </li> <li>Peer address: Included if directed advertising is used. Otherwise, set to NULL.   </li> </ul> </li> <li>struct bt_data:Description of different data types that can be encoded into advertising data. <ul> <li>Populate the flags using the helper macro BT_DATA_BYTES().          The Flags byte is a bitmask, meaning each bit represents a distinct piece of information. To set multiple flags, you combine their individual bit values using the bitwise OR operator (|).     Example:     <pre><code>#include &lt;zephyr/bluetooth/bluetooth.h&gt;\n#include &lt;zephyr/bluetooth/gap.h&gt;\n/* Set the advertising flags */\nBT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR|BT_LE_AD_GENERAL), // no BR/EDR support , General Discoverable\n</code></pre></li> <li>Set the advertising packet data using the helper macro BT_DATA()      <ul> <li>Declare the Manufacturer Specific Data:     Manufacturer Specific Data is used to create and include custom data in Bluetooth LE advertising. The data to be included can be in any format suitable for your use case/application.      The first two bytes in the Manufacturer Specific Data are the company identifier as registered in Bluetooth SIG in the Assigned Numbers Document. For educational/testing purposes, we will use Nordic Semiconductor Company Identifier.  </li> </ul> </li> <li>Example:     <pre><code>/* Declare the Company identifier (Company ID) */\n#define COMPANY_ID_CODE 0x0059      // Nordic Semiconductor Company Identifier.\n\ntypedef struct adv_mfg_data {\n    uint16_t company_code; /* Company Identifier Code. */\n    uint16_t custom_data; /* custom data */\n} adv_mfg_data_type;\n\n/* Define and initialize a variable of type adv_mfg_data_type */\nstatic adv_mfg_data_type adv_mfg_data = { COMPANY_ID_CODE, 0x0000 };\n\n/* Declare the advertising packet */\nstatic const struct bt_data ad[] = {\n/* Set the advertising flags */\nBT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR), // no BR/EDR support\n/* Set the advertising packet data:  manufacturer data */\nBT_DATA(BT_DATA_MANUFACTURER_DATA, (unsigned char *)&amp;adv_mfg_data, sizeof(adv_mfg_data)),   \n};\n</code></pre></li> </ul> </li> </ul>"},{"location":"introduction_to_GAP/#functions","title":"Functions","text":"<ul> <li>bt_le_adv_start:     In Zephyr, once your Bluetooth stack is initialized (with bt_enable()), the bt_le_adv_start() function is your primary tool for making your device discoverable to others using BLE advertising. This function sets advertisement parameters, advertisement data, scan response data and start advertising. <pre><code>int bt_le_adv_start (   const struct bt_le_adv_param *  param,\n                    const struct bt_data *  ad,     //Data to be used in advertisement packets.\n                    size_t  ad_len,                 //Number of elements in ad\n                    const struct bt_data *  sd,     //Data to be used in scan response packets.\n                    size_t  sd_len )                //Number of elements in sd\n</code></pre><ul> <li><code>size_t   ad_len or sd_len</code>:     In programming APIs for BLE, you often define your advertising data as an array or list of these individual AD elements. The \"number of elements in ad\" would then be the size of that array/list.     An advertising packet might contain:         Element 1: Flags (BT_LE_AD_NO_BREDR)         Element 2: Complete Local Name (\"My Sensor Device\")         Element 3: List of 16-bit Service UUIDs (e.g., for a Heart Rate Service)  </li> <li>Returns      Zero on success or (negative) error code otherwise.</li> <li>Example()     <pre><code>/*\n* This example snippet demonstrates BLE advertising setup.\n* It relies on standard Bluetooth LE API definitions (e.g., from `bluetooth/bluetooth.h`\n* and `bluetooth/gap.h`) and associated structure definitions (e.g., `struct bt_le_adv_param`,\n* `struct bt_data`) that would typically be found in your project's header files.\n*/\nint err;\n// adv date: ad, no scan response data\nerr = bt_le_adv_start(adv_param, ad, ARRAY_SIZE(ad), NULL, 0);\nif (err) {\n    LOG_ERR(\"Advertising failed to start (err %d)\", err);\n} else {\nLOG_INF(\"Advertising started (%d times)\", broadcast_count + 1);\n}\n</code></pre></li> </ul> </li> <li>bt_le_adv_stop:      Stop advertising.  <ul> <li>Returns:     Zero on success or (negative) error code otherwise.     In major Bluetooth stacks like Zephyr's, functions for stopping advertising are safe to call even if no advertising is currently active.</li> </ul> </li> <li>bt_le_adv_update_data:      Dynamically update the content of your advertising and/or scan response packets while the device is already actively advertising.      <code>c     int bt_le_adv_update_data(const struct bt_data *ad, size_t ad_len,               const struct bt_data *sd, size_t sd_len)</code>     It doesn't typically stop the current advertising interval and immediately restart; instead, the change takes effect for the next scheduled advertisement.     You generally cannot update advertising data using bt_le_adv_update_data() if the advertising is currently stopped.</li> </ul>"},{"location":"introduction_to_GAP/#3-scanner-module","title":"3. Scanner module","text":"<p>While the GAP in BLE defines the core roles and procedures for device discovery and connection establishment\u2014including both advertising and scanning concepts\u2014the practical software implementation often encapsulates scanning functionality within a dedicated module. This design promotes modularity and better code organization.</p> <p>Consequently, when developing applications that involve scanning, you'll need to include specific headers for the scanning module in addition to the general GAP headers. For instance, in environments like Zephyr or Nordic Connect SDK, you'd include: <pre><code>    #include &lt;zephyr/bluetooth/gap.h&gt;\n    #include &lt;bluetooth/scan.h&gt;\n</code></pre> Here, <code>&lt;zephyr/bluetooth/gap.h&gt;</code> provides general GAP-related definitions and APIs, while <code>&lt;bluetooth/scan.h&gt;</code> specifically offers functions and structures for configuring and executing BLE scan operations. You can find detailed information about the scanner module in its official documentation: Nordic_Scanner_module.</p>"},{"location":"introduction_to_GAP/#initialization-and-configuration","title":"Initialization and Configuration","text":"<p>This step covers functions essential for setting up the scanner and defining its fundamental operational parameters. This is where you prepare the scanning mechanism before it becomes active. - bt_scan_init      This function initializes the BLE Scanning Module. Proper initialization ensures the module is ready to execute scan operations and handle subsequent connection attempts based on the provided configuration.     <pre><code>void bt_scan_init(const struct bt_scan_init_param *init);\n</code></pre>     - Parameters:         - <code>const struct bt_scan_init_param *init</code>  - bt_scan_cb_register      This function registers a set of callbacks that allow your application to monitor and react to various events occurring during the BLE scanning process. By registering these callbacks, your application gains visibility into when scan filters are matched, when no devices are found for a filter, or when connection attempts fail after a scan.     <pre><code>void bt_scan_cb_register(struct bt_scan_cb *cb);\n</code></pre>     - Parameters:         - <code>struct bt_scan_cb *cb</code>             A pointer to a structure containing the function pointers for your application's scanning callbacks.              The <code>BT_SCAN_CB_INIT</code> macro is a convenient way to initialize a <code>struct bt_scan_cb</code> instance with your specific callback functions. It streamlines the process by setting up the structure with the provided function pointers.                  </p>"},{"location":"introduction_to_GAP/#scan-filtering","title":"Scan Filtering","text":"<p>Before starting the actual scan, you'll typically want to define what kind of advertisement packets you're interested in. Functions in this category allow you to add, remove, and manage filters, ensuring your application only processes relevant scan reports. - bt_scan_filter_add      This function allows you to add a new filter to the BLE scanning module. By applying filters, your application can reduce the number of irrelevant advertisement reports it receives, thereby saving processing power and focusing on devices or services of interest.     <pre><code>int bt_scan_filter_add(enum bt_scan_filter_type type, const void *data);\n</code></pre>     - Parameters:         - <code>enum bt_scan_filter_type type</code>              Specifies the type of filter to be added. This enumeration defines the criteria for filtering, such as device address, advertising data (e.g., UUIDs, manufacturer data).             - BT_SCAN_FILTER_TYPE_NAME: Filter for names.             - BT_SCAN_FILTER_TYPE_SHORT_NAME: Filter for short names.             - BT_SCAN_FILTER_TYPE_ADDR: Filter for addresses.             - BT_SCAN_FILTER_TYPE_UUID: Filter for UUIDs.             - BT_SCAN_FILTER_TYPE_APPEARANCE: Filter for appearances.             - BT_SCAN_FILTER_TYPE_MANUFACTURER_DATA: Filter for manufacturer data.         - <code>const void *data</code>             A pointer to the specific data for the filter. The type and structure of this data depend on the type parameter.     - Return         0 on success, or a negative error code if the operation failed (e.g., no available space for the filter or the filter already exists). - bt_scan_filter_enable      This function enables configured scanning filters. It allows you to specify which types of filters should be active and how multiple enabled filters should be combined to determine a match. This provides fine-grained control over which advertisement reports are processed by your application.     <pre><code>int bt_scan_filter_enable(u8_t mode, bool match_all);\n</code></pre>     - Parameters:         - <code>u8_t mode</code>             A bitmask indicating which types of filters to enable. You can combine multiple filter types using the bitwise OR operator.         - <code>bool match_all</code> <code>true</code>: AND operation. A device must match all enabled filter types (mode) to be considered a match. <code>false</code>: OR operation. A device will be considered a match if it matches any of the enabled filter types (mode).      - Return         0 If the operation was successful. Otherwise, a negative error code is returned. - bt_scan_filter_remove_all     This function clears out all the specific filter data you previously added. All your saved addresses, UUIDs, etc., are gone from the module's memory.     <pre><code>void bt_scan_filter_remove_all(void);\n</code></pre>     However, it does not change the state of the filtering mechanism itself. If you previously called <code>bt_scan_filter_enable</code> to turn the filtering on, it remains on.</p>"},{"location":"introduction_to_GAP/#scan-control","title":"Scan Control","text":"<p>This step manages the active state of the scanner. This includes starting the scanning process or stopping it entirely. - bt_scan_start      This function starts the scanning according to the configuration set during the initialization.     <pre><code>int bt_scan_start(enum bt_scan_type scan_type);\n</code></pre>     - Parameters:         - <code>enum bt_scan_type scan_type</code>             - <code>BT_SCAN_TYPE_SCAN_PASSIVE</code>: The scanner (Observer role) only listens for advertisement packets from other devices. It does not transmit any packets, such as scan requests.              - <code>BT_SCAN_TYPE_SCAN_ACTIVE</code>:  In active scanning, the scanner actively participates in the discovery process. When it receives an advertising packet from a scannable or connectable advertiser, it sends a Scan Request (SCAN_REQ) packet back to that advertiser.     - Return         0 If the operation was successful. Otherwise, a negative error code is returned. - bt_scan_stop     Function for stopping scanning.     <pre><code>int bt_scan_stop(void);\n</code></pre></p>"},{"location":"introduction_to_GAP/#4-connection","title":"4. Connection","text":"<p>Upon receiving a connectable advertisement, the scanner can decide to send a connection request packet back to the advertiser. This packet contains information necessary for establishing the connection, such as the scanner's address and desired connection parameters. If the advertiser accepts the connection request, a direct, point-to-point connection is established between the two devices. This transition marks a significant shift from the broadcast-based advertising phase to a communication link. Once a connection is established, both the Central and the Peripheral device have the capability to disconnect from the link.   Just as <code>scan.h</code> and <code>scan.c</code> form a scanner module, a separate <code>conn.h</code> and <code>conn.c</code> module is used to provide the core functions and definitions necessary for managing a BLE connection. You can find detailed information about the scanner module in its official documentation: Connection Management</p> <pre><code>    #include &lt;zephyr/bluetooth/conn.h&gt;\n</code></pre>"},{"location":"introduction_to_GAP/#registering-connection-instance-and-callback-functions","title":"Registering Connection Instance and Callback Functions","text":"<ul> <li>bt_conn:     This struct is a fundamental data structure within the BLE stack that uniquely represents and stores all essential information about a connection. it can be initially defined as NULL and then assigned a valid connection object when a connection is successfully established.</li> <li>bt_conn_cb:      This structure is used for tracking the state of a connection.        Data Fields:      <ul> <li>connected:      The connected callback function, part of the <code>bt_conn_cb</code> structure, is invoked by the BLE stack to notify the application when a new connection has been successfully established, providing the connection object (<code>conn</code>) and any error status (<code>err</code>).     <pre><code>void(* bt_conn_cb::connected) (struct bt_conn *conn, uint8_t err)\n</code></pre></li> <li>disconnected:      The disconnected callback function is called by the BLE stack to inform the application when an active connection has been terminated, providing the connection object and the specific reason for the disconnection.     <pre><code>void(* bt_conn_cb::disconnected) (struct bt_conn *conn, uint8_t reason)\n</code></pre></li> <li>The <code>bt_conn_cb</code> structure also can include function pointers to handle other crucial connection events, such as updates to connection parameters or changes in the connection's security level...</li> </ul> </li> <li>bt_conn_cb_register:      This function registers a set of callbacks to monitor connection states, returning <code>0</code> on success or <code>-EEXIST</code> if the callbacks have already been registered.     <pre><code>int bt_conn_cb_register (   struct bt_conn_cb * cb  )   \n</code></pre></li> </ul>"},{"location":"introduction_to_GAP/#core-functions-for-active-ble-connections","title":"Core Functions for Active BLE Connections","text":"<ul> <li> <p>bt_conn_ref:     This function is used to increment the reference count of a given struct <code>bt_conn</code> object. In systems like BLE stacks, reference counting is a common memory management technique to ensure that an object is not deallocated (freed from memory) while other parts of the code are still using it.</p> <p>When you provide a connection object <code>conn</code> and call this function, you are telling the stack that you are now using this object and it should be kept alive. The function returns the connection object itself (with its incremented reference count) or NULL if the object's reference count was already zero. - Example: <pre><code>static struct bt_conn *current_conn = NULL;\n\n// The connected callback function\nstatic void on_connected(struct bt_conn *conn, uint8_t err)\n{\n    //store connection object with its reference count  \n    current_conn = bt_conn_ref(conn);\n}\n</code></pre></p> </li> <li> <p>bt_conn_get_info:     This function provides connection information and returns <code>0</code> on success or (negative) error code on failure.     <pre><code>    int bt_conn_get_info    (   const struct bt_conn *  conn, struct bt_conn_info * info )\n</code></pre></p> <ul> <li>Parameters <ul> <li><code>bt_conn *    conn</code>      Connection object.</li> <li><code>bt_conn_info *   info</code>      The struct <code>bt_conn_info</code> is a data structure used to provide detailed, read-only information about an active BLE connection, such as the Connection Role (Central or Peripheral), Security level and current Connection state, among other relevant parameters.   </li> </ul> </li> </ul> </li> </ul>"},{"location":"introduction_to_GAP/#managing-disconnection-in-ble","title":"Managing Disconnection in BLE","text":"<ul> <li> <p>bt_conn_unref:      This function is used to decrement the reference count of a struct <code>bt_conn</code> object. For every <code>bt_conn_ref</code> call, there should typically be a corresponding <code>bt_conn_unref</code> call to decrement the reference count when you're done with the object.       <pre><code>void bt_conn_unref (   struct bt_conn *    conn    )   \n</code></pre></p> </li> <li> <p>bt_conn_disconnect:     This function disconnect an active connection with the specified reason code or cancel pending outgoing connection.     <pre><code>int bt_conn_disconnect  (   struct bt_conn *    conn,   uint8_t reason )\n</code></pre></p> <ul> <li>Parameters <ul> <li><code>bt_conn *    conn</code>      Connection object.</li> <li><code>reason</code> <ul> <li><code>BT_HCI_ERR_REMOTE_USER_TERM_CONN</code>: The remote device intentionally disconnected (disconnect reason for a normal disconnect).</li> <li><code>BT_HCI_ERR_AUTH_FAIL</code>: Authentication failed.</li> <li><code>BT_HCI_ERR_REMOTE_LOW_RESOURCES</code>: Remote device disconnected due to insufficient resources.</li> <li><code>BT_HCI_ERR_REMOTE_POWER_OFF</code>: Remote device powered off or reset.</li> <li><code>BT_HCI_ERR_UNSUPP_REMOTE_FEATURE</code>: Remote device doesn't support a requested feature.</li> <li><code>BT_HCI_ERR_PAIRING_NOT_SUPPORTED</code>: Remote device doesn't support a requested feature.</li> <li><code>BT_HCI_ERR_UNACCEPT_CONN_PARAM</code>: Remote device rejected proposed connection parameters.</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"introduction_to_Ktimer/","title":"How to Use a Timer?","text":"<p>In Zephyr RTOS, a <code>k_timer</code> is a fundamental kernel object that allows your application to execute a specific function (a callback) after a defined period of time has expired. It's a precise way to introduce time-based behavior into your concurrent applications.</p> <p>Think of a <code>k_timer</code> as a programmable alarm clock within your embedded system. You set the alarm, and when the time comes, a pre-defined action is triggered.</p> <p>Here, we'll cover the fundamental steps for using timers in Zephyr. For a more in-depth understanding and advanced configurations, please refer to the Timer APIs. </p>"},{"location":"introduction_to_Ktimer/#timer-expiry-function","title":"Timer Expiry Function","text":"<p>This function is the heart of your timer's functionality. It's a special callback function that Zephyr's kernel automatically executes when a specific timer finishes counting down or \"expires.\"    </p> <p>For example: <pre><code>void my_timer_expiry_handler(struct k_timer *timer_id){\n  LOG_INF(\"My timer expired!\");\n  // Add your code to run when the timer expires\n}\n</code></pre></p>"},{"location":"introduction_to_Ktimer/#define-and-initialize-a-timer","title":"Define and Initialize a Timer.","text":"<p>The <code>K_TIMER_DEFINE()</code> macro in Zephyr is a powerful tool for statically defining and initializing a kernel timer. <pre><code>  K_TIMER_DEFINE(name, expiry_fn, stop_fn)\n</code></pre></p> <ul> <li>Parameters: <ul> <li><code>name</code>: The name you give to your timer instance.  </li> <li><code>expiry_fn</code>: This is a function pointer to your timer's expiry handler. This function will be called by Zephyr's kernel whenever the timer finishes counting down (i.e., it \"expires\"). </li> <li><code>stop_fn</code>: This is an optional function pointer to your timer's stop handler. This function will be called by Zephyr's kernel if the timer is stopped before it expires. This is useful for cleanup or specific actions if a timer is canceled early.</li> </ul> </li> </ul>"},{"location":"introduction_to_Ktimer/#start-the-timer","title":"Start the Timer","text":"<p>This function starts a timer, and resets its status to zero. The timer begins counting down using the specified duration and period values.     <pre><code>void k_timer_start(struct k_timer *timer, k_timeout_t duration, k_timeout_t period)\n</code></pre>   - Parameters:     - <code>timer</code>: Address of timer.     - <code>duration</code>  specifies the initial delay before the timer first expires and its <code>expiry_fn</code> (callback) is executed.     - <code>period</code> specifies the subsequent interval at which the timer will repeatedly expire after the initial duration has passed. If period is <code>K_NO_WAIT</code> or <code>0</code>, the timer will only expire once (one-shot).</p>"},{"location":"introduction_to_Ktimer/#performing-non-trivial-actions","title":"Performing Non-Trivial Actions","text":"<p>When a Zephyr <code>k_timer</code> expires, its associated expiry function (callback) is executed within the context of the system clock interrupt handler (ISR context). This is a very high-priority execution environment designed for minimal latency with strict limitations.</p> <p>Many application-level operations, especially those involving complex subsystems like the Bluetooth stack (e.g., <code>bt_le_adv_start()</code>, <code>bt_le_adv_stop()</code>), are non-trivial actions. They involve multiple steps, potentially acquire internal locks, and might even block temporarily. Such operations cannot be safely or reliably performed directly from an ISR context.</p> <ul> <li> <p>The Solution: Using the System Workqueue To overcome these limitations while still initiating work on a periodic basis, the common and recommended pattern is as follows:</p> <ol> <li> <p>Timer Expiry (ISR Context): When the <code>k_timer</code> expires, its expiry function (running in the ISR) performs only one, very quick action: it submits a work item to the system workqueue. This is a safe and non-blocking operation from an ISR.</p> </li> <li> <p>Workqueue Execution (Thread Context): The system workqueue is managed by its own dedicated kernel thread. This thread runs at a lower priority than ISRs. When the work item is submitted, the workqueue thread will eventually pick it up and execute the associated work handler function.   </p> </li> </ol> </li> </ul>"},{"location":"introduction_to_Ktimer/#example","title":"Example","text":"<p>```c         void my_work_handler(struct k_work work)         {         / do the processing that needs to be done*/         }</p> <pre><code>    //define and initialize a work item.\n    K_WORK_DEFINE(my_work, my_work_handler);\n\n    void my_timer_handler(struct k_timer *timer_id)\n    {\n      //submit a work item to the system workqueue\n      k_work_submit(&amp;my_work);\n    }\n    // define a timer instance\n    K_TIMER_DEFINE(my_timer, my_timer_handler, NULL);\n    //start periodic timer that will expire for the first time after 100 milliseconds.\n    // After the first expiry, it will repeatedly expire every 500 milliseconds.\n    k_timer_start(&amp;my_timer, K_MSEC(100), K_MSEC(500));\n</code></pre> <p>```</p>"}]}